//---------------------------------------------------------------------------
// PROJECT      : TEST-DOG
// FILENAME     : xml_reporter.hpp
// DESCRIPTION  : Concrete XML reporting class.
// COPYRIGHT    : Andy Thomas (C)
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// LICENSE
//---------------------------------------------------------------------------
// This file is part of the "TEST-DOG" program.
// TEST-DOG is free software: you can redistribute it and/or
// modify it under the terms of the GNU General Public License as published
// by the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// TEST-DOG is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// You should have received a copy of the GNU General Public License
// along with TEST-DOG.  If not, see <http://www.gnu.org/licenses/>.
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// INCLUDES
//---------------------------------------------------------------------------
#include "xml_reporter.hpp"
#include "testdog/unit_test.hpp"
#include "util.hpp"

//---------------------------------------------------------------------------
// DECLARATIONS
//---------------------------------------------------------------------------
using namespace testdog;

namespace testdog {

// XML Elements
const char* const TEST_ROOT_ELEM = "test-root";
const char* const TEST_RUN_ELEM = "test-run";
const char* const START_TIME_TYPE = "start-run";
const char* const TIMESTAMP_ELEM = "timestamp";
const char* const TEST_SUITE_ELEM = "test-suite";
const char* const TEST_CASE_ELEM = "test-case";
const char* const TEST_TIME_TYPE = "start-test";
const char* const FAIL_ELEM = "fail-condition";
const char* const PASS_ELEM = "pass-condition";
const char* const INFO_ELEM = "info";
const char* const ERROR_ELEM = "test-error";
const char* const DURATION_ELEM = "duration";
const char* const TEST_DURATION_TYPE = "test-case";
const char* const ALL_DURATION_TYPE = "total-time";
const char* const RESULT_ELEM = "test-result";
const char* const END_TIME_TYPE = "end-run";
const char* const STATS_ELEM = "statistics";
const char* const STAT_RAN_ELEM = "ran";
const char* const STAT_SKIP_ELEM = "skipped";
const char* const STAT_PASS_ELEM = "passed";
const char* const STAT_FAIL_ELEM = "failed";
const char* const STAT_ERROR_ELEM = "errors";
const char* const STAT_PASS_PERC = "pass-rate";

// XML Attributes
const char* const NAME_ATTRIB = "name";
const char* const VERSION_ATTRIB = "version";
const char* const TOTAL_TESTS_ATTRIB = "total-tests";
const char* const SCOPE_ATTRIB = "scope";
const char* const AUTHOR_ATTRIB = "author";
const char* const FILE_ATTRIB = "filename";
const char* const LINE_ATTRIB = "line";
const char* const TYPE_NAME_ATTRIB = "type-name";
const char* const ENCODING_ATTRIB = "encoding";
const char* const UNITS_ATTRIB = "units";

// Values
const char* const BTS_NOT_RUN_VAL = "not-run";
const char* const BTS_SKIPPED_VAL = "skipped";
const char* const BTS_PASSED_VAL = "passed";
const char* const BTS_FAILED_VAL = "failed";
const char* const BTS_TEST_ERROR_VAL = "error";
const char* const RUN_NONE_VAL = "none";
const char* const RUN_ALL_VAL = "all";
const char* const RUN_SUITE_VAL = "suite";
const char* const RUN_TEST_VAL = "test";

const char* const GEN_COMMENT = "Test report generated by: ";
}
//---------------------------------------------------------------------------
// CLASS xml_reporter : PROTECTED MEMBERS
//---------------------------------------------------------------------------
std::string xml_reporter::m_indent() const
{
  // Return indentation
  if (m_indent_cnt > 0) return std::string(m_indent_cnt, ' ');
  else return "";
}
//---------------------------------------------------------------------------
std::string xml_reporter::s_timestamp(std::time_t t, const std::string& t_name)
{
  // Generate time element
  std::string rslt = "<" + std::string(TIMESTAMP_ELEM) + " ";

  if (!t_name.empty())
  {
    rslt += std::string(TYPE_NAME_ATTRIB) + "=\"" + t_name + "\" ";
  }

  return rslt + std::string(ENCODING_ATTRIB) + "=\"iso8601\">" + iso_time(t) +
    "</" + std::string(TIMESTAMP_ELEM) + ">";
}
//---------------------------------------------------------------------------
std::string xml_reporter::s_duration(int sec, const std::string& t_name)
{
  // Generate time element
  std::string rslt = "<" + std::string(DURATION_ELEM) + " ";

  if (!t_name.empty())
  {
    rslt += std::string(TYPE_NAME_ATTRIB) + "=\"" + t_name + "\" ";
  }

  return rslt + std::string(UNITS_ATTRIB) + "=\"sec\">" + int_to_str(sec) +
    "</" + std::string(DURATION_ELEM) + ">";
}
//---------------------------------------------------------------------------
std::string xml_reporter::s_rslt_str(const basic_test* tc)
{
  // Overral result of test
  switch(tc->state())
  {
    case BTS_NOT_RUN: return BTS_NOT_RUN_VAL;
    case BTS_SKIPPED: return BTS_SKIPPED_VAL;
    case BTS_PASSED: return BTS_PASSED_VAL;
    case BTS_FAILED: return BTS_FAILED_VAL;
    case BTS_TEST_ERROR: return BTS_TEST_ERROR_VAL;
    default: return "";
  }
}
//---------------------------------------------------------------------------
std::string xml_reporter::s_event_str(const event_item& eit, bool rep_loc)
{
  // Build condition element and return result
  // <fail-condition file="./src/main.cpp" line="29"/>sa == sb<fail-condition>
  std::string t_str;

  switch(eit.item_type)
  {
    case ET_PASS: t_str = PASS_ELEM; break;
    case ET_FAIL: t_str = FAIL_ELEM; break;
    case ET_ERROR: t_str = ERROR_ELEM; break;
    case ET_MSG: t_str = INFO_ELEM; break;
    default: return "";
  }

  std::string rslt = "<" + t_str;

  if (rep_loc && eit.line_num > 0)
  {
    rslt += " " + std::string(LINE_ATTRIB) + "=\"" +
      int_to_str(eit.line_num) + "\"";
  }

  rslt += ">";
  rslt += xml_esc(eit.msg_str);

  return rslt + "</" + t_str + ">";
}
//---------------------------------------------------------------------------
// CLASS xml_reporter : PUBLIC MEMBERS
//---------------------------------------------------------------------------
xml_reporter::xml_reporter(const runner* owner)
  : basic_reporter(owner)
{
  // Constructor

  // Set default values
  m_indent_step = 2;
  m_report_loc = m_runner_ptr->report_loc();

  // Zero
  clear();
}
//---------------------------------------------------------------------------
int xml_reporter::indent_step() const
{
  // Accessor
  return m_indent_step;
}
//---------------------------------------------------------------------------
void xml_reporter::set_indent_step(int is)
{
  // Mutator
  if (is < 0) is = 0;
  m_indent_step = is;
}
//---------------------------------------------------------------------------
bool xml_reporter::report_loc() const
{
  // Accessor
  return m_report_loc;
}
//---------------------------------------------------------------------------
void xml_reporter::set_report_loc(bool rl)
{
  // Mutator
  m_report_loc = rl;
}
//---------------------------------------------------------------------------
void xml_reporter::clear()
{
  // Clear internal data
  m_indent_cnt = 0;
  m_suite_added = false;
  m_current_suite.clear();
}
//---------------------------------------------------------------------------
std::ostream& xml_reporter::gen_start(std::ostream& os)
{
  // Write header to stream
  clear();

  // Write XML log header to output stream
  std::string cs_str = m_runner_ptr->report_charset();
  os << m_indent() << "<?xml version=\"1.0\" ";
  if (!cs_str.empty()) os << "encoding=\"" << cs_str << "\"";
  os << "?>\n";

  // Comment
  os << m_indent() << "<!-- " << GEN_COMMENT << " " << LIB_NAME << " ";
  os << LIB_VERSION << " -->\n";

  // Root test run element
  os << m_indent() << "<" << TEST_ROOT_ELEM;
  os << " " << NAME_ATTRIB << "=\"" << xml_esc(m_runner_ptr->project_name()) << "\"";
  os << " " << VERSION_ATTRIB << "=\"" << xml_esc(m_runner_ptr->project_version()) << "\"";
  os << " " << TOTAL_TESTS_ATTRIB << "=\"" << m_runner_ptr->registered_count() << "\"";

  os << ">\n";
  m_indent_cnt += m_indent_step;

  // Start time
  os << m_indent() << s_timestamp(m_runner_ptr->start_time(), START_TIME_TYPE) << "\n";

  // Test run
  os << m_indent() << "<" << TEST_RUN_ELEM;
  os << " " << SCOPE_ATTRIB << "=\"";

  switch(m_runner_ptr->run_scope())
  {
    case RUN_NONE: os << RUN_NONE_VAL << "\""; break;
    case RUN_ALL: os << RUN_ALL_VAL << "\""; break;
    case RUN_SUITE: os << RUN_SUITE_VAL << "\""; break;
    case RUN_TEST: os << RUN_TEST_VAL << "\""; break;
    default: os << "\""; break;
  }

  os << ">\n";
  m_indent_cnt += m_indent_step;

  return os;
}
//---------------------------------------------------------------------------
std::ostream& xml_reporter::gen_test(std::ostream& os, const basic_test* tc)
{
  // Write test case to stream. tc cannot be null.
  if (tc->state() != BTS_NOT_RUN)
  {
    // Initialize
    event_item eit;
    std::string type_elem;
    std::size_t lsz = tc->event_log().size();

    // Test suite
    if (tc->suite_name() != m_current_suite || !m_suite_added)
    {
      if (m_suite_added)
      {
        // Close old suite
        m_indent_cnt -= m_indent_step;
        os << m_indent() << "</" << TEST_SUITE_ELEM << ">\n";
      }

      // Add new suite
      m_suite_added = true;
      m_current_suite = tc->suite_name();

      os << m_indent() << "<" << TEST_SUITE_ELEM;
      os << " " << NAME_ATTRIB << "=\"" << xml_esc(m_current_suite) << "\"";
      os << ">\n";
      m_indent_cnt += m_indent_step;
    }

    // Add test case
    os << m_indent() << "<" << TEST_CASE_ELEM;
    os << " " << NAME_ATTRIB << "=\"" << xml_esc(tc->test_name()) << "\"";
    os << " " << FILE_ATTRIB << "=\"" << xml_esc(tc->filename()) << "\"";
    os << " " << AUTHOR_ATTRIB << "=\"" << xml_esc(tc->author()) << "\"";
    os << ">\n";
    m_indent_cnt += m_indent_step;


    if (tc->state() != BTS_SKIPPED)
    {
      // Timestamp
      os << m_indent() << s_timestamp(tc->start_time(), TEST_TIME_TYPE) << "\n";

      // Write events
      for(std::size_t n = 0; n < lsz; ++n)
      {
        os << m_indent() << s_event_str(tc->event_log()[n], m_report_loc) << "\n";
      }

      // Test duration
      os << m_indent() << s_duration(tc->test_duration(),
        TEST_DURATION_TYPE) << "\n";
    }

    // Test result
    os << m_indent() << "<" << RESULT_ELEM << ">";
    os << s_rslt_str(tc);
    os << "</" << RESULT_ELEM << ">\n";

    // Close test case
    m_indent_cnt -= m_indent_step;
    os << m_indent() << "</" << TEST_CASE_ELEM << ">\n";
  }

  return os;
}
//---------------------------------------------------------------------------
std::ostream& xml_reporter::gen_end(std::ostream& os)
{
  // Write footer to stream
  if (m_suite_added)
  {
    // Close old suite
    m_indent_cnt -= m_indent_step;
    os << m_indent() << "</" << TEST_SUITE_ELEM << ">\n";
  }

  // Close test run
  m_indent_cnt -= m_indent_step;
  os << m_indent() << "</" << TEST_RUN_ELEM << ">\n";

  // Statistics
  os << m_indent() << "<" << STATS_ELEM << ">\n";
  m_indent_cnt += m_indent_step;

  os << m_indent() << "<" << STAT_RAN_ELEM << ">";
  os << m_runner_ptr->stat_result(ST_RAN);
  os << "</" << STAT_RAN_ELEM << ">\n";

  os << m_indent() << "<" << STAT_SKIP_ELEM << ">";
  os << m_runner_ptr->stat_result(ST_SKIPPED);
  os << "</" << STAT_SKIP_ELEM << ">\n";

  os << m_indent() << "<" << STAT_PASS_ELEM << ">";
  os << m_runner_ptr->stat_result(ST_PASSED);
  os << "</" << STAT_PASS_ELEM << ">\n";

  os << m_indent() << "<" << STAT_FAIL_ELEM << ">";
  os << m_runner_ptr->stat_result(ST_FAILED);
  os << "</" << STAT_FAIL_ELEM << ">\n";

  os << m_indent() << "<" << STAT_ERROR_ELEM << ">";
  os << m_runner_ptr->stat_result(ST_ERRORS);
  os << "</" << STAT_ERROR_ELEM << ">\n";

  os << m_indent() << "<" << STAT_PASS_PERC<< ">";
  os << m_runner_ptr->stat_result(ST_PASS_RATE);
  os << "</" << STAT_PASS_PERC << ">\n";

  // Close statistics
  m_indent_cnt -= m_indent_step;
  os << m_indent() << "</" << STATS_ELEM << ">\n";

  // Test run end time
  os << m_indent() << s_timestamp(m_runner_ptr->end_time(), END_TIME_TYPE) << "\n";

  // Test duration
  os << m_indent() << s_duration(m_runner_ptr->duration(), ALL_DURATION_TYPE) << "\n";

  // Close root
  m_indent_cnt -= m_indent_step;
  os << m_indent() << "</" << TEST_ROOT_ELEM << ">\n";

  return os;
}
//---------------------------------------------------------------------------
