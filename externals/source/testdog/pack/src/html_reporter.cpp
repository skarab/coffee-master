//---------------------------------------------------------------------------
// PROJECT      : TEST-DOG
// FILENAME     : html_reporter.hpp
// DESCRIPTION  : Concrete HTML reporting class.
// COPYRIGHT    : Andy Thomas (C)
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// LICENSE
//---------------------------------------------------------------------------
// This file is part of the "TEST-DOG" program.
// TEST-DOG is free software: you can redistribute it and/or
// modify it under the terms of the GNU General Public License as published
// by the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// TEST-DOG is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// You should have received a copy of the GNU General Public License
// along with TEST-DOG.  If not, see <http://www.gnu.org/licenses/>.
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// INCLUDES
//---------------------------------------------------------------------------
#include "html_reporter.hpp"
#include "testdog/private/basic_test.hpp"
#include "testdog/unit_test.hpp"
#include "util.hpp"

//---------------------------------------------------------------------------
// DECLARATIONS
//---------------------------------------------------------------------------
using namespace testdog;

namespace testdog {

// Report tag names
// Updating these can be used to form the basis for internationalization
const char* const BASIC_TITLE = "Test Report";
const char* const PROJECT_NAME_LEADER = "PROJECT: ";
const char* const PROJECT_VERSION_LEADER = "Version: ";
const char* const REG_COUNT_LEADER = "Registered Tests: ";
const char* const SCOPE_LEADER = "Run Scope: ";
const char* const RUN_NONE_STR = "No Tests were Run";
const char* const RUN_ALL_STR = "All Tests";
const char* const RUN_SUITE_STR = "Specified Suite";
const char* const RUN_TEST_STR = "Specified Test Only";
const char* const START_TIME_LEADER = "Start Time: ";
const char* const SUITE_LEADER = "TEST SUITE: ";
const char* const DEF_SUITE_NAME = "[Default Suite]";
const char* const REPORT_CONTENTS = "Report Contents";
const char* const TEST_RESULTS = "Test Run Results";
const char* const TEST_STATS = "Statistical Results";
const char* const FAIL_DETAILS = "Test Failure Information";
const char* const ERROR_DETAILS = "Test Error Information";
const char* const PASS_DETAILS = "Test Pass Information";
const char* const DISABLED_TESTS = "Disabled Tests";
const char* const DISABLED_NOTES = "The following tests were skipped:";
const char* const END_TIME_LEADER = "End Time: ";
const char* const DURATION_LEADER = "Run Duration: ";
const char* const TAB_TEST_NAME = "Test Name";
const char* const TAB_AUTHOR = "Author";
const char* const TAB_START_TIME = "Start Time";
const char* const TAB_DURATION = "Duration";
const char* const TAB_RESULT = "Result";
const char* const STAT_TAB_METRIC = "Statistic";
const char* const STAT_TAB_VALUE = "Value";
const char* const STAT_TAB_RAN = "Tests Ran";
const char* const STAT_TAB_SKIPPED = "Skipped";
const char* const STAT_TAB_PASSED = "Passed";
const char* const STAT_TAB_FAILED = "Failed";
const char* const STAT_TAB_ERRORS = "Test Errors";
const char* const STAT_TAB_PERC = "Pass Rate";
const char* const NONE_STR = "NONE";
const char* const TEST_LEADER = "Test: ";
const char* const BTS_NOT_RUN_STR = "NOT RUN";
const char* const BTS_SKIPPED_STR = "SKIPPED";
const char* const BTS_PASSED_STR = "PASSED";
const char* const BTS_FAILED_STR = "FAILED ";
const char* const BTS_ERROR_STR = "TEST ERROR";
const char* const GENERATED_LEADER = "Test report generated by: ";
}
//---------------------------------------------------------------------------
// CLASS html_reporter : PROTECTED MEMBERS
//---------------------------------------------------------------------------
std::string html_reporter::m_indent(int chrs) const
{
  // Return indentation
  if (chrs < 0) chrs = m_indent_cnt;

  if (chrs > 0) return std::string(chrs, ' ');
  else return "";
}
//---------------------------------------------------------------------------
std::ostream& html_reporter::m_generate_css(std::ostream& os)
{
  // Generate interal CCS, or specify external sheet
  std::string temp_str = m_runner_ptr->html_report_stylesheet();

  // Default styles
  os << m_indent() << "<style type=\"text/css\">\n";
  m_indent_cnt += m_indent_step;

  os << m_indent() << "th {background-color:silver; font-weight:bold;";
  os << " border-style:solid; border-width:thin}\n";

  os << m_indent() << "td {border-style:solid; border-width:thin}\n";

  os << m_indent() << ".pass-cell-col {background-color:lightgreen}\n";
  os << m_indent() << ".fail-cell-col {background-color:red}\n";

  m_indent_cnt -= m_indent_step;
  os << m_indent() << "</style>\n";

  if (!temp_str.empty())
  {
    os << m_indent() << "<link rel=\"stylesheet\" href=\"";
    os << temp_str;
    os << "\" type=\"text/css\" />\n";
  }

  return os;
}
//---------------------------------------------------------------------------
std::string html_reporter::s_clean_id(const std::string& id_str)
{
  // Clean up id_str and return result
  std::string rslt;

  std::size_t sz = id_str.size();
  for(std::size_t n = 0; n < sz; ++n)
  {
    if ((id_str[n] >= 'a' && id_str[n] <= 'z') ||
      (id_str[n] >= '0' && id_str[n] <= '9') ||
      id_str[n] == '_' || id_str[n] == ':' ||
      id_str[n] == '.' || id_str[n] == '-')
    {
      rslt += id_str[n];
    }
    else
    if (id_str[n] == 0x20)
    {
      rslt += '_';
    }
    else
    if (id_str[n] >= 'A' && id_str[n] <= 'Z')
    {
      rslt += static_cast<char>(id_str[n] + 0x20);
    }
  }

  return rslt;
}
//---------------------------------------------------------------------------
std::string html_reporter::s_page_link(const std::string& id_str,
  const std::string& name_str)
{
  // Make "id_str" a link to an anchor.
  // Example: s_link("suite", "UCD_TESTS");
  // returns: <a href=\"#anchor_suite">UCD_TESTS</a>
  return "<a href=\"#anchor_" + s_clean_id(id_str) + "\">" + name_str + "</a>";
}
//---------------------------------------------------------------------------
std::string html_reporter::s_page_anchor(const std::string& id_str)
{
  // Make "cat_str" an (empty) anchor.
  // Example: s_anchor("suite");
  // returns: <span id=\"anchor_suite" />
  return "<p id=\"anchor_" + s_clean_id(id_str) + "\"></p>";
}
//---------------------------------------------------------------------------
std::string html_reporter::s_rslt_str(const basic_test* tc)
{
  // Overral result of test
  switch(tc->state())
  {
    case BTS_NOT_RUN: return BTS_NOT_RUN_STR;
    case BTS_SKIPPED: return BTS_SKIPPED_STR;
    case BTS_PASSED: return BTS_PASSED_STR;
    case BTS_FAILED: return std::string(BTS_FAILED_STR)
      + " (" + int_to_str(tc->fail_cnt()) + ")";
    case BTS_TEST_ERROR: return BTS_ERROR_STR;
    default: return "";
  }
}
//---------------------------------------------------------------------------
std::string html_reporter::s_th_str(const std::string& content,
  const std::string& width)
{
  // Make table header cell
  if (!width.empty())
  {
    return "<th style=\"width:" + width + "\">" + content + "</th>";
  }
  else
  {
    return "<th>" + content + "</th>";
  }
}
//---------------------------------------------------------------------------
std::string html_reporter::s_td_str(const std::string& content, bool bold,
    const std::string& class_id)
{
  // Make table data cell
  std::string rslt = "<td";

  if (!class_id.empty()) rslt += " class=\"" + class_id + "\"";
  rslt += ">";

  if (bold) rslt += "<strong>" + content + "</strong>";
  else rslt += content;

  return rslt + "</td>";
}
//---------------------------------------------------------------------------
std::string html_reporter::s_cond_classid(bool passed)
{
  // Condition color
  if (passed) return "pass-cell-col";
  else return "fail-cell-col";
}
//---------------------------------------------------------------------------
void html_reporter::m_build_trace(std::ostream& os,
  const std::vector<std::string>& trace_vec, const std::string& title_elem)
{
  // During test case generation, trace output if buffered to a vector
  // array for adding to the report later. In this call, we take the vector
  // an build the trace sections of the report. Each test case is stored as
  // two items in the array. The first is the test name, and section is the
  // text formatted trace. Therefore, even numbered array indexes always
  // hold the test name for the trace that follows in the next item.

  // Start local indent - we expect 2 steps instead <html> & <body> tags
  std::size_t sz = trace_vec.size();

  if (sz > 0 && sz % 2 == 0)
  {
    std::string t_name, t_cont;

    for(std::size_t n = 0; n < sz; n += 2)
    {
      // Extract test name and trace contents
      t_name = trace_vec[n];
      t_cont = trace_vec[n+1];

      if (t_cont.empty()) t_cont = NONE_STR;

      if (!t_name.empty())
      {
        // Write title anchor
        os << m_indent() << s_page_anchor(t_name) + "\n";

        // Make title, i.e. "....<h3>Suite::TestName</h3>"
        os << m_indent() << "<" << title_elem << ">";
        os << TEST_LEADER << t_name << "</" + title_elem << ">\n";

        // Stream <ul> start
        os << m_indent() + "<ul>\n";
        m_indent_cnt += m_indent_step;

        // Steam trace content, replacing newlines with <li> pairs
        os << m_indent() + "<li>";
        os << str_replace(t_cont, "\n", "</li>\n" + m_indent() + "<li>");
        os << "</li>\n";

        // Stream <ul> end
        m_indent_cnt -= m_indent_step;
        os << m_indent() + "</ul>\n";

      }
    }
  }
  else
  {
    // No tests
    os << m_indent() << "<p>" << NONE_STR << "</p>\n";
  }
}
//---------------------------------------------------------------------------
// CLASS html_reporter : PUBLIC MEMBERS
//---------------------------------------------------------------------------
html_reporter::html_reporter(const runner* owner, html_reporter::style_t rs)
  : basic_reporter(owner)
{
  // Constructor
  m_style = rs;
  m_indent_step = 2;
  m_html_report_author_col = true;

  // Create internal text reporter for test details
  // NB. We disable the test name leader as each output
  // block will have the test name as the heading.
  m_text_reporter_ptr = new text_reporter(m_runner_ptr, true);
  m_text_reporter_ptr->set_testname_leader(false);
  m_text_reporter_ptr->set_suite_breaks(false);

  // Zero
  clear();
}
//---------------------------------------------------------------------------
html_reporter::~html_reporter()
{
  try
  {
    // Destructor
    delete m_text_reporter_ptr;
  }
  catch(...)
  {
  }
}
//---------------------------------------------------------------------------
html_reporter::style_t html_reporter::style() const
{
  // Accessor
  return m_style;
}
//---------------------------------------------------------------------------
void html_reporter::set_style(html_reporter::style_t s)
{
  // Mutator
  m_style = s;
}
//---------------------------------------------------------------------------
int html_reporter::indent_step() const
{
  // Accessor
  return m_indent_step;
}
//---------------------------------------------------------------------------
void html_reporter::set_indent_step(int is)
{
  // Mutator
  if (is < 0) is = 0;
  m_indent_step = is;
}
//---------------------------------------------------------------------------
bool html_reporter::report_loc() const
{
  // Accessor
  return m_text_reporter_ptr->report_loc();
}
//---------------------------------------------------------------------------
void html_reporter::set_report_loc(bool rl)
{
  // Mutator
  m_text_reporter_ptr->set_report_loc(rl);
}
//---------------------------------------------------------------------------
bool html_reporter::html_report_author_col() const
{
  // Returns whether the HTML reports have an "author" column in
  // the result tables.
  return m_html_report_author_col;
}
//---------------------------------------------------------------------------
void html_reporter::set_html_report_author_col(bool a)
{
  // Sets whether the HTML reports have an "author" column in
  // the result tables.
  m_html_report_author_col = a;
}
//---------------------------------------------------------------------------
void html_reporter::clear()
{
  // Clear internal data
  m_suite_added = false;
  m_current_suite.clear();
  m_indent_cnt = 0;
  m_text_reporter_ptr->clear();

  m_pass_trace.clear();
  m_fail_trace.clear();
  m_error_trace.clear();
  m_skipped_tests.clear();
}
//---------------------------------------------------------------------------
std::ostream& html_reporter::gen_start(std::ostream& os)
{
  // Write header to stream
  clear();

  // DOCTYPE
  os << "<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.1//EN\" ";
  os << "\"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">\n";

  // HTML element
  os << "<html xmlns=\"http://www.w3.org/1999/xhtml\">\n";
  m_indent_cnt += m_indent_step;

  // Head
  os << m_indent() << "<head>\n";
  m_indent_cnt += m_indent_step;

  // Content-Type
  std::string temp_str = m_runner_ptr->report_charset();
  os << m_indent() << "<meta http-equiv=\"Content-Type\" ";
  os << "content=\"text/html;";
  if (!temp_str.empty()) os << " charset=" << temp_str;
  os << "\" />\n";

  // Title
  temp_str = xml_esc(m_runner_ptr->project_name());
  os << m_indent() << "<title>" << BASIC_TITLE;
  if (!temp_str.empty()) os << " | " << temp_str;
  os << "</title>\n";

  // Stylesheet
  m_generate_css(os);

  // Head closure
  m_indent_cnt -= m_indent_step;
  os << m_indent() << "</head>\n";

  // Body
  os << m_indent() << "<body>\n";
  m_indent_cnt += m_indent_step;

  // Content - Title
  os << m_indent() << "<h1>" << BASIC_TITLE << "</h1>\n";

  // Project information
  os << m_indent() << "<p>\n";
  m_indent_cnt += m_indent_step;

  temp_str = xml_esc(m_runner_ptr->project_name());
  if (!temp_str.empty())
  {
    os << m_indent() << "<strong>" << PROJECT_NAME_LEADER << "</strong>";
    os << temp_str << "<br/>\n";
  }

  // Project version
  temp_str = xml_esc(m_runner_ptr->project_version());
  if (!temp_str.empty())
  {
    os << m_indent() << "<strong>" << PROJECT_VERSION_LEADER << "</strong>";
    os << temp_str << "<br/>\n";
  }

  // Test count
  os << m_indent() << "<strong>" << REG_COUNT_LEADER << "</strong>";
  os << m_runner_ptr->registered_count() << "<br/>\n";

  // Run scope
  os << m_indent() << "<strong>" << SCOPE_LEADER << "</strong>";

  switch(m_runner_ptr->run_scope())
  {
    case RUN_NONE: os << RUN_NONE_STR << "<br/>\n"; break;
    case RUN_ALL: os << RUN_ALL_STR << "<br/>\n"; break;
    case RUN_SUITE: os << RUN_SUITE_STR << "<br/>\n"; break;
    case RUN_TEST: os << RUN_TEST_STR << "<br/>\n"; break;
    default: os << "<br/>\n"; break;
  }

  // Start time
  os << m_indent() << "<strong>" << START_TIME_LEADER << "</strong>";
  os << iso_time(m_runner_ptr->start_time()) << "<br/>\n";

  m_indent_cnt -= m_indent_step;
  os << m_indent() << "</p>\n";

  // Content - Title
  os << m_indent() << "<h2>" << REPORT_CONTENTS << "</h2>\n";

  // Build navigation list
  if (m_runner_ptr->contains_suites())
  {
    // Suite navigation
    // List
    os << m_indent() << "<ul>\n";
    m_indent_cnt += m_indent_step;

    os << m_indent() << "<li>";
    os << s_page_link("main", "<strong>" +
      std::string(TEST_RESULTS) + "</strong>");
    os << "</li>\n";

    // Get suite names
    std::vector<std::string> suite_array;
    m_runner_ptr->enum_suite_names(suite_array);
    std::size_t sz = suite_array.size();

    for(std::size_t n = 0; n < sz; ++n)
    {
      if (suite_array[n].empty())
      {
        // Sub default name
        suite_array[n] = DEF_SUITE_NAME;
      }

      // Escape
      suite_array[n] = xml_esc(suite_array[n]);

      os << m_indent() << "<li>";
      os << s_page_link("suite_" + suite_array[n], suite_array[n]) << "</li>\n";
    }

    // List closure
    m_indent_cnt -= m_indent_step;
    os << m_indent() << "</ul>\n";
  }
  else
  {
    // List
    os << m_indent() << "<ul>\n";
    m_indent_cnt += m_indent_step;

    os << m_indent() << "<li>";
    os << s_page_link("main", "<strong>" +
      std::string(TEST_RESULTS) + "</strong>");
    os << "</li>\n";

    // List closure
    m_indent_cnt -= m_indent_step;
    os << m_indent() << "</ul>\n";
  }

  // Additional info

  // List
  os << m_indent() << "<ul>\n";
  m_indent_cnt += m_indent_step;

  os << m_indent() << "<li>";
  os << s_page_link("test_stats", "<strong>" +
    std::string(TEST_STATS) + "</strong>");
  os << "</li>\n";

  if (m_style != HTML_SUMMARY)
  {
    // Additional content
    os << m_indent() << "<li>";
    os << s_page_link("fail_details", FAIL_DETAILS);
    os << "</li>\n";

    os << m_indent() << "<li>";
    os << s_page_link("error_details", ERROR_DETAILS);
    os << "</li>\n";

    if (m_style == HTML_VERBOSE)
    {
      // Verbose only content
      os << m_indent() << "<li>";
      os << s_page_link("pass_details", PASS_DETAILS);
      os << "</li>\n";

      os << m_indent() << "<li>";
      os << s_page_link("disabled_tests", DISABLED_TESTS);
      os << "</li>\n";
    }
  }

  // List closure
  m_indent_cnt -= m_indent_step;
  os << m_indent() << "</ul>\n";

  // Main section
  os << m_indent() << s_page_anchor("main") << "\n";
  os << m_indent() << "<h2>" << TEST_RESULTS << "</h2>\n";

  return os;
}
//---------------------------------------------------------------------------
std::ostream& html_reporter::gen_test(std::ostream& os, const basic_test* tc)
{
  // Write test case to stream. tc cannot be null.
  if (tc->state() == BTS_SKIPPED)
  {
    if (m_style == HTML_VERBOSE)
    {
      // Record to skipped list
      m_skipped_tests.push_back(tc->full_name());
    }
  }
  else
  if (tc->state() != BTS_NOT_RUN)
  {
    // Set temp_str to be suite name
    std::string s_name = xml_esc(tc->suite_name());

    if (s_name != m_current_suite || !m_suite_added)
    {
      // New test suite
      if (m_suite_added)
      {
        // Close old suite
        m_indent_cnt -= m_indent_step;
        os << m_indent() << "</table>\n";
      }

      // Add new suite
      m_suite_added = true;
      m_current_suite = s_name;

      // Apply default name
      if (m_runner_ptr->contains_suites())
      {
        // Add suite header
        if (s_name.empty()) s_name = DEF_SUITE_NAME;
        os << m_indent() << s_page_anchor("suite_" + s_name) << "\n";
        os << m_indent() << "<h3>" << SUITE_LEADER << s_name << "</h3>\n";
      }

      // Open table (defines width properties)
      os << m_indent() << "<table style=\"width:75%; max-width:100em\">\n";
      m_indent_cnt += m_indent_step;

      // Header row
      os << m_indent() << "<tr>\n";
      m_indent_cnt += m_indent_step;

      os << m_indent() << s_th_str(TAB_TEST_NAME) << "\n";

      if (m_html_report_author_col)
      {
        os << m_indent() << s_th_str(TAB_AUTHOR, "15%") << "\n";
      }

      os << m_indent() << s_th_str(TAB_START_TIME, "20%") << "\n";
      os << m_indent() << s_th_str(TAB_DURATION, "15%") << "\n";
      os << m_indent() << s_th_str(TAB_RESULT, "15%") << "\n";

      // Close row
      m_indent_cnt -= m_indent_step;
      os << m_indent() << "</tr>\n";
    }

    // Data row
    os << m_indent() << "<tr>\n";
    m_indent_cnt += m_indent_step;

    // Set temp_str to be full test name
    std::string t_name = xml_esc(tc->full_name());

    if (m_style == HTML_VERBOSE ||
      (m_style != HTML_SUMMARY && tc->state() != BTS_PASSED))
    {
      // Add event to corresponding vector - these
      // will be appended to the report later. We append
      // the test name, followed by the trace text, so
      // that even number elements always content the
      // test name, and trace contents will follow.
      std::stringstream ss;
      m_text_reporter_ptr->gen_test(ss, tc);
      std::string t_cont = xml_esc(trim_str(ss.str()));

      switch(tc->state())
      {
        // Append to applicable vector
        case BTS_PASSED:
          m_pass_trace.push_back(t_name);
          m_pass_trace.push_back(t_cont);
          break;
        case BTS_FAILED:
          m_fail_trace.push_back(t_name);
          m_fail_trace.push_back(t_cont);
          break;
        case BTS_TEST_ERROR:
          m_error_trace.push_back(t_name);
          m_error_trace.push_back(t_cont);
          break;
        default:
          break;
      }

      // Linked test name
      t_name = s_page_link(t_name, t_name);
    }

    os << m_indent() << s_td_str(t_name) << "\n";

    if (m_html_report_author_col)
    {
      os << m_indent() << s_td_str(xml_esc(tc->author())) << "\n";
    }

    os << m_indent() << s_td_str(iso_time(tc->start_time())) << "\n";
    os << m_indent() << s_td_str(duration_str(tc->test_duration())) << "\n";

    // Color pass/fail value
    bool pass_ok = (tc->state() == BTS_PASSED);
    os << m_indent() << s_td_str(s_rslt_str(tc), !pass_ok,
      s_cond_classid(pass_ok)) << "\n";

    // Close row
    m_indent_cnt -= m_indent_step;
    os << m_indent() << "</tr>\n";
  }

  return os;
}
//---------------------------------------------------------------------------
std::ostream& html_reporter::gen_end(std::ostream& os)
{
  // Write footer to stream
  if (m_suite_added)
  {
    // Close last table
    m_indent_cnt -= m_indent_step;
    os << m_indent() << "</table>\n";
  }
  else
  if (m_runner_ptr->stat_result(ST_RAN) == 0)
  {
    os << m_indent() << "<p>" << NONE_STR << "</p>";
  }

  // Statistics
  os << m_indent() << s_page_anchor("test_stats") << "\n";
  os << m_indent() << "<h2>" << TEST_STATS << "</h2>\n";

  // Define colors
  std::string pass_id, fail_id, err_id;
  if (m_runner_ptr->stat_result(ST_PASSED)
    == m_runner_ptr->stat_result(ST_RAN))
  {
    pass_id = s_cond_classid(true);
  }

  if (m_runner_ptr->stat_result(ST_FAILED) > 0)
  {
    fail_id = s_cond_classid(false);
  }

  if (m_runner_ptr->stat_result(ST_ERRORS) > 0)
  {
    err_id = s_cond_classid(false);
  }

  // Open table
  os << m_indent() << "<table style=\"width:20em\">\n";
  m_indent_cnt += m_indent_step;

  // Header row
  os << m_indent() << "<tr>\n";
  m_indent_cnt += m_indent_step;

  os << m_indent() << s_th_str(STAT_TAB_METRIC) << "\n";
  os << m_indent() << s_th_str(STAT_TAB_VALUE) << "\n";

  // Close row
  m_indent_cnt -= m_indent_step;
  os << m_indent() << "</tr>\n";

  os << m_indent() << "<tr>\n";
  m_indent_cnt += m_indent_step;
  os << m_indent() << s_td_str(STAT_TAB_RAN, true) << "\n";
  os << m_indent() << s_td_str(int_to_str(
    m_runner_ptr->stat_result(ST_RAN))) << "\n";
  m_indent_cnt -= m_indent_step;
  os << m_indent() << "</tr>\n";

  os << m_indent() << "<tr>\n";
  m_indent_cnt += m_indent_step;
  os << m_indent() << s_td_str(STAT_TAB_SKIPPED, true) << "\n";
  os << m_indent() << s_td_str(int_to_str(
    m_runner_ptr->stat_result(ST_SKIPPED))) << "\n";
  m_indent_cnt -= m_indent_step;
  os << m_indent() << "</tr>\n";

  os << m_indent() << "<tr>\n";
  m_indent_cnt += m_indent_step;
  os << m_indent() << s_td_str(STAT_TAB_PASSED, true) << "\n";
  os << m_indent() << s_td_str(int_to_str(
    m_runner_ptr->stat_result(ST_PASSED))) << "\n";
  m_indent_cnt -= m_indent_step;
  os << m_indent() << "</tr>\n";

  os << m_indent() << "<tr>\n";
  m_indent_cnt += m_indent_step;
  os << m_indent() << s_td_str(STAT_TAB_FAILED, true) << "\n";
  os << m_indent() << s_td_str(int_to_str(
    m_runner_ptr->stat_result(ST_FAILED)), false, fail_id) << "\n";
  m_indent_cnt -= m_indent_step;
  os << m_indent() << "</tr>\n";

  os << m_indent() << "<tr>\n";
  m_indent_cnt += m_indent_step;
  os << m_indent() << s_td_str(STAT_TAB_ERRORS, true) << "\n";
  os << m_indent() << s_td_str(int_to_str(
    m_runner_ptr->stat_result(ST_ERRORS)), false, err_id) << "\n";
  m_indent_cnt -= m_indent_step;
  os << m_indent() << "</tr>\n";

  os << m_indent() << "<tr>\n";
  m_indent_cnt += m_indent_step;
  os << m_indent() << s_td_str(STAT_TAB_PERC, true) << "\n";
  os << m_indent() << s_td_str(int_to_str(
    m_runner_ptr->stat_result(ST_PASS_RATE)) + "%", false, pass_id) << "\n";
  m_indent_cnt -= m_indent_step;
  os << m_indent() << "</tr>\n";

  m_indent_cnt -= m_indent_step;
  os << m_indent() << "</table>\n";

  // Test end time
  os << m_indent() << "<p>\n";
  m_indent_cnt += m_indent_step;

  os << m_indent() << "<strong>" << END_TIME_LEADER << "</strong>";
  os << iso_time(m_runner_ptr->end_time()) << "<br/>\n";

  // Duration
  os << m_indent() << "<strong>" << DURATION_LEADER << "</strong>";
  os << duration_str(m_runner_ptr->duration()) << " (approx.) <br/>\n";

  m_indent_cnt -= m_indent_step;
  os << m_indent() << "</p>\n";

  if (m_style != HTML_SUMMARY)
  {
    // Additional content
    os << m_indent() << s_page_anchor("fail_details") << "\n";
    os << m_indent() << "<h2>" << FAIL_DETAILS << "</h2>\n";
    m_build_trace(os, m_fail_trace, "h3");

    os << m_indent() << s_page_anchor("error_details") << "\n";
    os << m_indent() << "<h2>" << ERROR_DETAILS << "</h2>\n";
    m_build_trace(os, m_error_trace, "h3");

    if (m_style == HTML_VERBOSE)
    {
      // Verbose only content
      os << m_indent() << s_page_anchor("pass_details") << "\n";
      os << m_indent() << "<h2>" << PASS_DETAILS << "</h2>\n";
      m_build_trace(os, m_pass_trace, "h3");

      // Disabled tests
      os << m_indent() << s_page_anchor("disabled_tests") << "\n";
      os << m_indent() << "<h2>" << DISABLED_TESTS << "</h2>\n";

      // Build list of disabled tests
      std::size_t sk_sz = m_skipped_tests.size();

      if (sk_sz > 0)
      {
        os << m_indent() << "<p>" << DISABLED_NOTES << "</p>\n";

        os << m_indent() << "<ul>\n";
        m_indent_cnt += m_indent_step;

        for(std::size_t n = 0; n < sk_sz; ++n)
        {
          os << m_indent() << "<li>" << m_skipped_tests[n] << "</li>\n";
        }

        m_indent_cnt -= m_indent_step;
        os << m_indent() << "</ul>\n";
      }
      else
      {
        os << m_indent() << "<p>" << NONE_STR << "</p>\n";
      }
    }
  }

  // Generator
  os << m_indent() << "<p>" << GENERATED_LEADER;
  os << LIB_NAME << " " << LIB_VERSION;
  os << "</p>\n";

  // Close body
  m_indent_cnt -= m_indent_step;
  os << m_indent() << "</body>\n";

  // Close html
  m_indent_cnt -= m_indent_step;
  os << m_indent() << "</html>\n";

  return os;
}
//---------------------------------------------------------------------------
